/*

给定正整数  n，找到若干个完全平方数（比如  1, 4, 9, 16, ...）使得它们的和等于
n。你需要让组成和的完全平方数的个数最少。

示例  1:
输入: n = 12 输出: 3 解释: 12 = 4 + 4 + 4. 

示例 2:
输入: n = 13 输出: 2 解释: 13 = 4 + 9.  

*/

// 动态规划
/*
1，对于正整数N, 所有的解都是 N = 一个整数的平方 + 另一个整数; 直白点, N = AxA + B
2, 而B又是由 "一个整数的平方 + 另一个整数" 组成的; 那么, B = CxC + D
3，总结下就是：正整数N = |x| + N' 而 N' = |x| + N''  (x是平方数)
4, 本题要解的问题：正整数N最少由多个平方数相加;

5, 那么，来讨论下最优解：N的最优解 = 1 + N’的最优解。dp[N] = dp[N'] + 1 
（最优解就是组成N'的和的完全平方数的最少个数，+1指的也是值组成N'完全平方的个数，比如12 = 4 + 8, 那么这个1就是指这个4，N'就是指这个8），那么这道题本质上就是要求N'是什么时dp[N']是最小的

拿12举例, 要求dp[12]，我们只需要观察：而不用考虑12 = 2 + 10； 12 = 5 + 7 这种
12 = 1 + 11
12 = 4 + 8
12 = 9 + 3

我们要得出3，8，11中谁的解最优，那么12的解就是它+1。dp[11]=3, dp[8]=2, dp[3]=3，最小的是dp[8]，最后结果就是dp[8]+1 (这里的1/4/9就相当于是N'+1的那个1了，因为1/4/9是完全平方数，所以+1)
那怎么得出3/8/11呢，就是答当前的12减去小于12的i的平方，小于12的是[1,12], 那就分别拿12 - 1*1；  12 - 2*2; 12 - 3 * 3; 看谁的dp[]最小
*/

var numSquares = function (n) {
    let dp = new Array(n + 1).fill(0); // 初始化dp数组
    for (let i = 1; i <= n; i++) {
        dp[i] = i; // 默认值设定
        // 默认值dp[i]和dp[小于i]的一一对比，同时排除不是完全平方的数字
        for (let j = 1; j * j <= i; j++) {
            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
        }
    }
    // 返回组成完全平方数的个数0
    return dp[n];
};


// ----------------------------------------- 求dp[4]为例
i = 1; dp[1] = Math.min(dp[1], dp[1 - 1 * 1] + 1) = 1;

i = 2; dp[2] = Math.min(dp[2], dp[2 - 1 * 1] + 1) = 2;

i = 3; dp[3] = Math.min(dp[3], dp[3 - 1 * 1] + 1) = 3;

i = 4; dp[4] = Math.min(dp[4], dp[4 - 1 * 1] + 1) = 4;
i = 4; dp[4] = Math.min(dp[4], dp[4 - 2 * 2] + 1) = 1; √

