// 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。
// 假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，
// 但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

// 出栈元素只可能是与上一个出栈元素紧邻的仍在栈中的元素（比如第二个例子，4他的上一个出栈元素是5，那么4是可以出栈的，4出完之后，3就和5相邻了，也就是3也可以出栈）、
// 或者是刚进栈的新元素。比如5每次让出来后又入栈
// 所以4、3、5是可以的, 接下来和5相邻的是2，5出了，只有2能出了


// 借用一个辅助的栈，开始从头入栈，先将第一个放入栈中，这里是1，然后判断刚入栈的那个是不是当前j对应的popv数组里的值是否相等，这里是4，很显然1≠4，
// 所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将j向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，
// 说明弹出序列不是该栈的弹出顺序

function IsPopOrder(pushV, popV) {
    let stack = [];
    for (let i = 0, j = 0; i < pushV.length; i++) {  //stack是辅助栈
        stack.push(pushV[i])
        //stack栈顶和popV里的每一个对比，相等的话，辅助栈stack出栈，也就是一直pop()，不相等则继续从for循环里压入新元素
        while (j < popV.length && stack[stack.length - 1] === popV[j]) {
            j++;
            stack.pop()
        }
    }
    if (stack.length == 0) {
        return true
    } else {
        return false
    }
}

IsPopOrder([1,2,3,4,5], [4,3,5,1,2]) // false
IsPopOrder([1,2,3,4,5], [4,3,5,2,1]) // true


// pushV=[1,2,3,4,5]，popV = [4,3,5,2,1]
// stack=[1] 1 !== 4  继续压栈  stack = [1,2], 2 !== 4 
// 这题的话直到stack=[1,2,3,4],栈顶元素和出栈顺序的第一个元素相等了,然后while循环4出，j+1, 3出，J+1, 2!==5
// 继续压栈, stack=[1,2,5],接下来5 === 5, J+1, stack=[1,2]